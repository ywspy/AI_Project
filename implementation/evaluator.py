"""Class for evaluating programs proposed by the Sampler."""
from __future__ import annotations

from abc import abstractmethod, ABC
import ast
import time
from collections.abc import Sequence
import copy
import numpy as np
from typing import Any, Type
import profile

from implementation import code_manipulation
from implementation import programs_database


class _FunctionLineVisitor(ast.NodeVisitor):
    """Visitor that finds the last line number of a function with a given name."""

    def __init__(self, target_function_name: str) -> None:
        self._target_function_name: str = target_function_name
        self._function_end_line: int | None = None

    def visit_FunctionDef(self, node: Any) -> None:
        """Collects the end line number of the target function."""
        if node.name == self._target_function_name:
            self._function_end_line = node.end_lineno
        self.generic_visit(node)

    @property
    def function_end_line(self) -> int:
        """Line number of the final line of function `target_function_name`."""
        assert self._function_end_line is not None
        return self._function_end_line


def _trim_function_body(generated_code: str) -> str:
    """
    Return only the *body* of the generated function, stripped of anything
    that follows it. Always returns a string ending with exactly one blank
    line, or the empty string on total failure.
    """
    import ast, textwrap

    if not generated_code.strip():
        return ""

    wrapped = (
        generated_code
        if generated_code.lstrip().startswith("def ")
        else f"def _tmp():\n{generated_code}"
    )

    try:
        tree = ast.parse(wrapped)
    except SyntaxError:
        return textwrap.indent(generated_code.rstrip() + "\n", " " * 4)

    fn_node = next(node for node in ast.walk(tree) if isinstance(node, ast.FunctionDef))

    if fn_node.name == "_tmp":
        inner = next((n for n in fn_node.body if isinstance(n, ast.FunctionDef)), None)
        if inner is not None:
            fn_node = inner

    lines = wrapped.splitlines()
    start = fn_node.body[0].lineno - 1
    end = fn_node.end_lineno

    body = "\n".join(lines[start:end]).rstrip() + "\n\n"
    return body


def _sample_to_program(
    generated_code: str,
    version_generated: int | None,
    template: code_manipulation.Program,
    function_to_evolve: str,
) -> tuple[code_manipulation.Function, str]:
    """Returns the compiled generated function and the full runnable program."""
    body = _trim_function_body(generated_code)
    if version_generated is not None:
        body = code_manipulation.rename_function_calls(
            code=body,
            source_name=f'{function_to_evolve}_v{version_generated}',
            target_name=function_to_evolve
        )

    program = copy.deepcopy(template)
    evolved_function = program.get_function(function_to_evolve)
    evolved_function.body = body
    evolved_function.source = program
    return evolved_function, str(program)


class Sandbox(ABC):
    """Sandbox for executing generated code."""

    @abstractmethod
    def run(
        self,
        program: str,
        function_to_run: str,
        function_to_evolve: str,
        inputs: Any,
        test_input: str,
        timeout_seconds: int,
        **kwargs,
    ) -> tuple[Any, bool]:
        """Returns `function_to_run(test_input)` and whether execution succeeded."""
        raise NotImplementedError('Must provide a sandbox for executing untrusted code.')


def _calls_ancestor(program: str, function_to_evolve: str) -> bool:
    """Returns whether the generated function is calling an earlier version."""
    for name in code_manipulation.get_functions_called(program):
        if name.startswith(f'{function_to_evolve}_v'):
            return True
    return False


class Evaluator:
    """Class that analyses functions generated by LLMs."""

    def __init__(
        self,
        database: programs_database.ProgramsDatabase,
        template: code_manipulation.Program,
        function_to_evolve: str,
        function_to_run: str,
        inputs: Sequence[Any],
        timeout_seconds: int = 30,
        sandbox_class: Type[Sandbox] = Sandbox
    ):
        self._database = database
        self._template = template
        self._function_to_evolve = function_to_evolve
        self._function_to_run = function_to_run
        self._inputs = inputs
        self._timeout_seconds = timeout_seconds
        self._sandbox = sandbox_class()

    def analyse(
        self,
        sample: str,
        island_id: int | None,
        version_generated: int | None,
        **kwargs,
    ) -> None:
        """Analyses a sampled program and registers it if valid."""
        new_function, program = _sample_to_program(
            sample, version_generated, self._template, self._function_to_evolve
        )

        start_time = time.time()

        metrics, ok = self._sandbox.run(
            program,
            self._function_to_run,
            self._function_to_evolve,
            self._inputs,
            None,
            self._timeout_seconds,
            **kwargs,
        )

        elapsed = time.time() - start_time
        new_function.score_details = metrics

        if ok and "composite" in metrics and np.isfinite(metrics["composite"]):
            scores_per_test = {"composite": metrics["composite"]}
            self._database.register_program(
                new_function,
                island_id,
                scores_per_test,
                **kwargs,
                evaluate_time=elapsed,
            )
        else:
            print(f"[WARNING] Dropped invalid program. ok={ok}, metrics={metrics}")

            profiler: profile.Profiler = kwargs.get("profiler", None)
            if profiler:
                new_function.global_sample_nums = kwargs.get("global_sample_nums", None)
                new_function.score = None
                new_function.sample_time = kwargs.get("sample_time", None)
                new_function.evaluate_time = elapsed
                profiler.register_function(new_function)
